
#|

Assume we have a set of points with gaussian errors contaminated with
outliers in some fraction f, and we want to recover the mean value of x

We express the probability distribution as

   P(x,xm,f) = (1-f) delta(x-xm) + f 1/[3s(1+((x-xm)/s)^2)^(1/2)]

where s is some width.  Note that this is un-normalized because
the second component has a 1/x tail and the integral 
is s*asinh(x/a)

The term 6s (=2*asinh(10)) ensures that the normalization of the contamination
term is 1 between -10s and 10s, however.

For fitting individual points xi with errors dxi, the likelihood is 

L(f,s,xm) = Sum_i  {(1-f) gaussian(xi-xbar,dxi) + 
                        f  1/[6s(1+((x-xm)/s)^2)^(1/2)]}

We always optimize over xm and we may optimize over f or s.

|#


(defpackage bayes-outlier
  (:use #:cl)
  (:export 

   ))

(in-package bayes-outlier)

(defun %to-double-vec (seq)
  (cond ((typep seq '(simple-array double-float (*)))
	 seq)
	(t
	 (map '(simple-array double-float (*))
	      (lambda (x) (float x 1d0))
	      seq))))


(defun bayes-outlier-estimate-mean (xseq dxseq 
				    &key
				      (mean-guess nil)
				      (s 1.0) (f 0.1) 
				      (fit-s nil)
				      (fit-f nil)
				      (ftol 1d-7)
				      (scale 1d-7))
"Given a sequence of data XSEQ and its nominally Gaussian errors DXSEQ,
compute the best estimate of the mean and standard deviation,
returning (VALUES MEAN ERROR-ON-MEAN).

The model assumed is that (loosely defined) fraction (1-F) of the data are Gaussian,
and fraction F are outliers, with a probability distribution 
 1/sqrt(1+[x/f]^2)   - ie, a 1/x tail beyond s.     

S and F are specified, and may be fit if FIT-S and/or FIT-F
keywords are, but it is probably best not to do so."

  (let* ((xvec  (%to-double-vec xseq))
	 (dxvec (%to-double-vec dxseq))
	 (xmin (stats:min-of-elements xvec))
	 (xmax (stats:max-of-elements xvec))
	 (dx-med (stats:median-of-elements dxvec))
	 (s (float s 1d0))
	 (f (float f 1d0))
	 (scale (float scale 1d0))
	 (ftol  (float ftol 1d0))
	 ;; our initial guess
	 (starting-mean  (float (or mean-guess 0d0) 1d0))
	 (param-vec (make-array 3 :element-type 'double-float
				  :initial-contents 
				  (list 0d0 f s)))
	 (optim-flags (vector t fit-f fit-s))
	 (ps (powell:build-powell-struct  
	      3 
	      :name "BAYES-OUTLIER" :scale scale)))
    (declare (type (simple-array double-float (*)) xvec dxvec param-vec)
	     (type double-float dx-med starting-mean f))
    
    (flet ((prob-func (powell)
	     (declare (type powell:powell-struct powell)
		      (optimize speed))
	     (loop with pvec = (powell:powell-struct-x-vec powell)
		   with xm of-type double-float = (aref pvec 0)
		   with f  of-type double-float = (aref pvec 1)
		   with s  of-type double-float = (aref pvec 2)
		   with likelihood of-type double-float = 0d0
		   initially
		      (when (or (> f 1d0) (< f 0d0)
				(< s 1d-10)
				(> xm xmax)
				(< xm xmin))
			(setf (powell:powell-struct-y powell) 1d100)
			(return))
				
		   for x  of-type double-float across xvec
		   for xxm of-type double-float = (- x xm)
		   for %dx of-type double-float across dxvec 
		   for dx of-type double-float = (max %dx 1d-30) ;; avoid divide by zero
		   ;; compute term in the exponent separately to avoid
		   ;; long computation times for outliers
		   for inexpterm of-type double-float = (* -0.5d0 (expt (/ xxm dx) 2))
		   for expterm of-type double-float 
		     = (if (< inexpterm -500) 
			   0d0
			   (exp inexpterm))
		   for gaussterm of-type double-float
		     = (* (/ #.(/ 1 (sqrt (* 2 pi))) s) expterm)
		   for outlierterm of-type double-float
		     = (/ 1d0 (* #.(* 2 (asinh 10d0));; normalization
				 s
				 (sqrt
				  (+ 1d0 (expt (/ xxm s) 2)))))
		   do (incf likelihood
			    (log 
			     (+ #.(* 64 least-positive-double-float)
				(the (double-float 0d0)
				     (+ (* (- 1d0 f) gaussterm)
					(* f outlierterm))))))
		   finally (setf (powell:powell-struct-y powell)
				 (- likelihood)))
	     #+nil
	     (progn
	       (let ((pvec (powell:powell-struct-x-vec powell)))
		 (format t "m=~,15G f=~,4G s~,4G  L=~,15G~%" 
			 (aref pvec 0) (aref pvec 1) (aref pvec 2)
			 (powell:powell-struct-y powell)))
	       (sleep 0.1))
	     ))

      ;; if there is no mean-guess, then get the mean guess by walking across
      ;; xmin to xmax by  and fitting the function in steps
      (when (not mean-guess)
	(powell:init-powell-struct ps #'prob-func param-vec 
				   :optim-flags optim-flags)
	(setf starting-mean
	      (loop 
		with lik-min = most-positive-double-float 
		with best-mean = xmin
		for mean of-type double-float from xmin to xmax by dx-med
		do 
		   (setf (aref (powell:powell-struct-x-vec ps) 0) mean)
		   (funcall #'prob-func ps)
		   (when (< (powell:powell-struct-y ps) lik-min)
		     (setf best-mean mean)
		     (setf lik-min  (powell:powell-struct-y ps)))
		finally
		   (format t "Found guess of mean =~A~%" best-mean)
		   (return best-mean))))
      
      ;; now fix the best mean
      (setf (aref param-vec 0) starting-mean)
      (powell:init-powell-struct ps #'prob-func param-vec 
				 :optim-flags optim-flags)
      (powell:run-powell-on-ps #'prob-func ps ftol))))

    
